---
layout: default
title: UltraDAO
description: UltraDAO is the premier web3 creative studio building the future of decentralized IP and entertainment brands.
id: home
image: /assets/images/ultradao-cover.png
---

<div>
  <a
    href="/curated/2"
    class="no-underline preview-frame homepage flex flex-col-reverse md:flex-row gap-12"
  >
    <div id="momentaPreview"></div>
    <div class="momenta-details">
      <span class="curated-subtitle">curated series two</span>
      <h1>Momenta <em>by</em> r0zk0</h1>
      <span class="coming-soon">coming soon</span>
    </div>
  </a>
</div>

<div class="py-32">
  <h2 class="mb-10 max-w-2xl text-2xl md:text-3xl">
    UltraDAO is a community of artists, creators, art collectors, and fans. Come
    join us.
  </h2>

  <ul class="image-cover-container w-full">
    <li>
      <a href="/creator-membership">
        <img src="/assets/images/thumbnail-creator-membership.png" />
        <h2>Creator Membership</h2>
      </a>
    </li>
    <li>
      <a href="/ultrapass">
        <img src="/assets/images/thumbnail-ultrapass.png" />
        <h2>ULTRAPASS&trade;</h2>
      </a>
    </li>
    <li>
      <a href="https://woodiesofficial.com">
        <img src="/assets/images/thumbnail-woodies.png" />
        <h2>Woodies</h2>
      </a>
    </li>
  </ul>
</div>

<script
  language="javascript"
  type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"
></script>

<script>
  p5.disableFriendlyErrors = true;

  function genTokenData(projectNum) {
    let data = {};
    let hash = "0x";
    for (var i = 0; i < 64; i++) {
      hash += Math.floor(Math.random() * 16).toString(16);
    }
    data.hash = hash;
    data.tokenId = (
      projectNum * 1000000 +
      Math.floor(Math.random() * 208)
    ).toString();
    return data;
  }
  let tokenData = genTokenData(123);

  // tokenData.hash = '0xfd0cd766df001660989c3e04a2900bbfe6bbff26f431520b6e849303dfd3ceaa'

  class Random {
    constructor() {
      this.useA = false;
      let sfc32 = function (uint128Hex) {
        let a = parseInt(uint128Hex.substr(0, 8), 16);
        let b = parseInt(uint128Hex.substr(8, 8), 16);
        let c = parseInt(uint128Hex.substr(16, 8), 16);
        let d = parseInt(uint128Hex.substr(24, 8), 16);
        return function () {
          a |= 0;
          b |= 0;
          c |= 0;
          d |= 0;
          let t = (((a + b) | 0) + d) | 0;
          d = (d + 1) | 0;
          a = b ^ (b >>> 9);
          b = (c + (c << 3)) | 0;
          c = (c << 21) | (c >>> 11);
          c = (c + t) | 0;
          return (t >>> 0) / 4294967296;
        };
      };
      // seed prngA with first half of tokenData.hash
      this.prngA = new sfc32(tokenData.hash.substr(2, 32));
      // seed prngB with second half of tokenData.hash
      this.prngB = new sfc32(tokenData.hash.substr(34, 32));
      for (let i = 0; i < 1e6; i += 2) {
        this.prngA();
        this.prngB();
      }
    }
    // random number between 0 (inclusive) and 1 (exclusive)
    random_dec() {
      this.useA = !this.useA;
      return this.useA ? this.prngA() : this.prngB();
    }
    // random number between a (inclusive) and b (exclusive)
    random_num(a, b) {
      return a + (b - a) * this.random_dec();
    }
    // random integer between a (inclusive) and b (inclusive)
    // requires a < b for proper probability distribution
    random_int(a, b) {
      return Math.floor(this.random_num(a, b + 1));
    }
    // random boolean with p as percent liklihood of true
    random_bool(p) {
      return this.random_dec() < p;
    }
    // random value in an array of items
    random_choice(list) {
      return list[this.random_int(0, list.length - 1)];
    }
  }

  const Seed = tokenData.hash;
  let rnd = new Random();
  const screenMode =
    document.getElementById("momentaPreview").clientWidth <=
    document.getElementById("momentaPreview").clientHeight * 1
      ? 1
      : 0;
  // const random = new Random(Seed)
  const DEFAULT_SIZE = 1200;

  let ratio = 0.65;
  if (document.getElementById("momentaPreview").clientHeight < 421) {
    ratio = 1;
  }

  // const HEIGHT = Math.floor(!screenMode ? document.getElementById('momentaPreview').clientHeight : document.getElementById('momentaPreview').clientWidth *1.41)
  const high = Math.floor(
    document.getElementById("momentaPreview").clientHeight * ratio
  );
  const WIDTH = Math.floor(high / 1.5);
  const HEIGHT = Math.floor(WIDTH * 1.41);
  const DIM = Math.min(WIDTH, high);
  const M = DIM / DEFAULT_SIZE;

  function gauss() {
    var u = 0,
      v = 0;
    while (u === 0) u = rnd.random_dec(); //Converting [0,1) to (0,1)
    while (v === 0) v = rnd.random_dec();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  // let slices = rnd.random_int(4,12)*2;
  let slices = rnd.random_int(2, 6) * 4;
  let numShapes;

  var shape, mask, img;

  const fuzzyPixels = 12; // pixels

  let threshold = 0.4;

  let starting = 1;

  let style;
  let solid = rnd.random_dec();
  let clear = rnd.random_dec();
  let monochrome = rnd.random_dec();
  let inverse = rnd.random_dec();
  let elliptical = rnd.random_dec();
  let density = rnd.random_dec();
  let glitch = rnd.random_dec();
  let colorful = rnd.random_dec();
  let midnight = 0;
  let noon = 0;
  let sunrise = 0;
  let daylight;
  let graph;
  // let high
  let rndPix;

  let poster = 1;

  var padding = -200 * M;
  var padding2 = -500 * M;
  let start = 0;
  var startHeight;
  let cols;
  let colWidth;
  let runs = 0;
  let drops = [];
  let regular;
  let angular;
  let bold;
  let direction;

  let minutesNow;

  let mintnumber;

  var t;
  var num, vNum;
  var radius, mySize;
  var sizes = [];

  let v_planet = [];

  let maxruns;

  let colors = [];
  let color_setup = [];
  let backgrounds = [];
  let bgcol = [];

  color_setup[0] = "FCDE9C-FFA552-BA5624-381D2A-C4D6B0"
    .split("-")
    .map((a) => "#" + a);
  color_setup[1] = "f8f9fbBF-f9f6e040-45454cBF-ef9643b3-f0654380"
    .split("-")
    .map((a) => "#" + a);
  color_setup[2] = "f8f9fb-f9f6e0-45454c-ef9643-f06543"
    .split("-")
    .map((a) => "#" + a);
  //color_setup[3] = "fefefe-fffffb-fafdff-fef9fb-f7fcfe".split("-").map((a) => "#" + a);
  color_setup[3] = "084C61-DB504A-E3B505-4F6D7A-56A3A6"
    .split("-")
    .map((a) => "#" + a);

  color_setup[4] =
    "8c75ff-c553d2-2788f5-23054f-f21252-8834f1-c4dd92-184fd3-f9fee2-2E294E-541388-F1E9DA-FFD400-D90368-e9baaa-ffa07a-164555-ffe1d0-acd9e7-4596c7-6d8370-e45240-21d3a4-3303f9-cd2220-173df6-244ca8-a00360-b31016"
      .split("-")
      .map((a) => "#" + a);
  color_setup[5] = "025159-3E848C-7AB8BF-C4EEF2-A67458"
    .split("-")
    .map((a) => "#" + a);
  color_setup[6] = "10454F-506266-818274-A3AB78-BDE038"
    .split("-")
    .map((a) => "#" + a);
  color_setup[7] = "D96690-F28DB2-F2C9E0-89C2D9-88E8F2"
    .split("-")
    .map((a) => "#" + a);
  //color_setup[8] = "3D3522-4A442D-202020-58B09C-CAF7E2".split("-").map((a) => "#" + a);
  color_setup[8] = "FCDE9C-FFA552-BA5624-381D2A-C4D6B0"
    .split("-")
    .map((a) => "#" + a);
  color_setup[9] = "773344-E3B5A4-F5E9E2-0B0014-D44D5C"
    .split("-")
    .map((a) => "#" + a);
  color_setup[10] = "084C61-DB504A-E3B505-4F6D7A-56A3A6"
    .split("-")
    .map((a) => "#" + a);
  color_setup[11] = "EEE2DF-EED7C5-C89F9C-C97C5D-B36A5E"
    .split("-")
    .map((a) => "#" + a);
  // color_setup[12]= "000000-14213D-FCA311-E5E5E5-FFFFFF".split("-").map((a) => "#" + a);
  color_setup[12] = "0D1B2A-1B263B-415A77-778DA9-E0E1DD"
    .split("-")
    .map((a) => "#" + a);
  color_setup[13] = "0D1B2A-1B263B-415A77-778DA9-E0E1DD"
    .split("-")
    .map((a) => "#" + a);

  var color_setup1, color_setup2;

  let color_bg;

  let newSeed = Date.now();
  // var rndSeed = 'Seed'+newSeed
  var rndSeed = newSeed;
  var a = 2,
    b = 3;
  var th = 0,
    seg = 0.006;
  var r;
  var mySize;

  var noiseScale = 220,
    noiseStrength = 0.3;

  function setup() {
    randomSeed(rndSeed);
    console.log(Seed);
    rndPix = 14 * M;
    mintnumber = rnd.random_int(0, 300);
    if (mintnumber < 10) {
      mintnumber = "00" + mintnumber;
    } else if (mintnumber < 100) {
      mintnumber = "0" + mintnumber;
    }

    angleMode(DEGREES);
    direction = rnd.random_num(0, 360);

    regular = rnd.random_dec();
    angular = rnd.random_dec();
    bold = rnd.random_dec();

    if (inverse >= 0.4) {
      slices = rnd.random_int(2, 6) * 4;
    }

    style = rnd.random_dec();

    //   blendMode(HARD_LIGHT)

    mySize = min(windowWidth, windowHeight) * 0; //random(0.8,1.1);

    var myCanvas = createCanvas(WIDTH, HEIGHT); //high);
    myCanvas.parent("momentaPreview");
    pixelDensity(1);
    frameRate(25);

    graph = createGraphics(WIDTH, HEIGHT);
    graph.angleMode(DEGREES);
    graph.pixelDensity(1);
    colorMode(HSB, 360, 100, 100, 100);
    r = mySize / 2;

    if (density < 0 && monochrome > 0.9 && elliptical > 0.8) {
      cols = rnd.random_int(500, 900); //DEFAULT 180
    } else if (density < 0.6 && elliptical <= 0.8) {
      cols = rnd.random_int(20, 45); //DEFAULT 180 // CHECK used to be 35,80
    } else {
      cols = rnd.random_int(40, 65); // cols = rnd.random_int(70,160) //DEFAULT 180
    }
    if (slices < 9) {
      cols = rnd.random_int(40, 80);
    }

    console.log("cols: ", cols);

    colWidth = (width - 2 * padding) / cols;
    let bgPicker;
    if (slices < 9) {
      bgPicker = rnd.random_int(0, 4);
    } else {
      bgPicker = rnd.random_int(4, 7);
    }

    backgrounds[0] = [10, 80, 40];
    backgrounds[1] = [0, 0, 35];
    backgrounds[2] = [60, 2, 30];
    backgrounds[3] = [234, 86, 27];
    backgrounds[4] = [0, 0, 95];
    backgrounds[5] = [200, 14, 90];
    backgrounds[6] = [41, 15, 97];
    backgrounds[7] = [0, 0, 95];

    bgcol = backgrounds[bgPicker];

    if (slices < 9) {
      numShapes = 600; //cols*rnd.random_num(0.15,0.35);//rnd.random_int(250,400)//cols*rnd.random_num(0.5,2);
    } else {
      numShapes = rnd.random_int(50, 150); //cols*rnd.random_num(0.15,0.35);//rnd.random_int(250,400)//cols*rnd.random_num(0.5,2);
    }

    console.log("shapes: ", numShapes);

    graph.background(color(bgcol[0], bgcol[1], bgcol[2]));

    console.log(bgcol[2]);

    //   color_setup1 = colors7;
    let colPicker = rnd.random_int(0, 13);

    color_setup2 = color_setup[colPicker];

    colors[0] = rnd.random_choice(color_setup2); //rnd.random_choice(colors7);

    colors[1] = rnd.random_choice(color_setup2);
    if (colorful > 0.5 || slices < 9) {
      colors[2] = rnd.random_choice(color_setup2);
      colors[3] = rnd.random_choice(color_setup2);
    }
    if (slices < 9) {
      colors[4] = rnd.random_choice(color_setup2);
    }

    console.log("colors: ", colors);
    // background(color_bg);
    if (bold > 0.5) {
      num = rnd.random_int(3, 6);
    } else {
      num = rnd.random_int(4, 8);
    }

    let speedX = 0; //random(-1.5,1.5)
    for (let i = 0; i < cols; i++) {
      let strokeCol = color(rnd.random_choice(colors));
      let loc = createVector(
        padding + i * colWidth + colWidth / 4,
        random(padding, height - padding)
      );
      let angle = 180; //any value to initialize
      let dir = createVector(cos(angle), sin(angle));
      let speed = rnd.random_num(0.07, 0.33); // default: 0.9

      if (regular > 0) {
        drops[i] = new Drop(loc, dir, speed, strokeCol);
      }
      drops[i].draw();
    }

    radius = mySize * 1;
    for (let a = 0; a < TAU; a += TAU / num) {
      // sizes.push(random(0.1, 0.5))
      sizes.push(rnd.random_num(0.01, 0.5));
    }
    t = 0;

    shape = calcStuff(WIDTH, HEIGHT, slices);
    mask = createMask(shape.a, shape.o);

    background(0, 0, 0);
    filters();

    ///FEATURES

    //PALETTE: ...
    let palettes = [];
    palettes[0] = "74-75";
    palettes[1] = "Fire and Rain";
    palettes[2] = "Orange Crush";
    palettes[3] = "Ashes to Ashes";
    palettes[4] = "Shes a Rainbow";
    palettes[5] = "Cold Cold Ground";
    palettes[6] = "High & Dry";
    palettes[7] = "Pop Crimes";
    palettes[8] = "Camouflage";
    palettes[9] = "Fear and Love";
    palettes[10] = "Common People";
    palettes[11] = "Natural Anthem";
    palettes[12] = "A Simple Love";
    palettes[13] = "Sour Soul";
    let palette_f = palettes[colPicker];

    //BACKGROUND: ...

    let backgroundCol = [];

    backgroundCol[0] = "Ore";
    backgroundCol[1] = "Obsidian";
    backgroundCol[2] = "Granite";
    backgroundCol[3] = "Sapphire";
    backgroundCol[4] = "Alabaster";
    let background_f = backgroundCol[bgPicker];

    // SLICES: Number
    console.log("SEGMENTS: ", slices / 2);
    let segments_f = slices / 2;

    //SHAPE: elliptical / angular
    let shape_f;
    if (elliptical > 0.8 && solid < 0.7 && slices > 8) {
      shape_f = "Elliptical";
    } else {
      shape_f = "Angular";
    }

    //SYMMETRY: center, corners, horizontal, vertical
    if (inverse < 0.4) {
      symmetry_f = "Center";
    } else if (inverse < 0.5) {
      symmetry_f = "Horizontal";
    } else if (inverse < 0.6) {
      symmetry_f = "Vertical";
    } else {
      symmetry_f = "Corners";
    }

    //HAZE: low, medium, high
    let haze_f = "Low";
    if (clear > 0.5 && inverse < 0.4) {
      haze_f = "Medium";
    }
    if (inverse >= 0.4) {
      if (clear > 0.4) {
        haze_f = "Medium";
      }
      if (clear > 0.7 && monochrome <= 0.9) {
        haze_f = "High";
      }
    }

    //MONOCHROME: yes, no

    if (monochrome > 0.9) {
      mono_f = "Yes";
    } else {
      mono_f = "No";
    }

    let features = {
      Palette: palette_f,
      Background: background_f,
      Segments: segments_f,
      Shape: shape_f,
      Symmetry: symmetry_f,
      Haze: haze_f,
      Monochrome: mono_f,
    };

    console.log(features);
  }

  function filters() {
    let filter = new makeFilter();
    let filter2 = new makeFilter2();
    draw();
  }

  function draw() {
    let today = new Date();
    minutesNow = today.getHours() * 60 + today.getMinutes();

    if (minutesNow % 30000 == 0) {
      filters();
    }

    randomSeed(rndSeed);

    let ccc = color(bgcol[0], bgcol[1], bgcol[2]);
    if (slices < 9) {
      ccc.setAlpha(20);
    } else {
      ccc.setAlpha(100);
    }

    background(0, 0, 100);
    graph.background(ccc);
    if (monochrome <= 0.9) {
      graph.background(ccc);
    }
    //   }

    noFill();
    graph.strokeCap(ROUND);

    push();
    stroke(0, 0, 100, 30);
    strokeWeight(0.5 * M);
    pop();

    graph.push();

    for (let i = 0; i < cols; i += 1) {
      noStroke();
      drops[i].move();
    }
    graph.pop();

    t += rnd.random_num(-0.0012, 0.0012);

    th += seg;

    graph.image(overAllTexture2, 0, 0);

    runs += 1;
    mirror();

    bubbles(15, 0.05, 0.7);

    if (slices < 9) {
      monochrome = 0;
    }

    //   if(monochrome > 0.9){

    //     }else if(monochrome >0.4){
    //         if(poster == 1){
    //         //graph.filter(POSTERIZE, 9   )
    //         }

    //     }
    //
    //
    if (poster == 1) {
      if (slices < 9) {
        graph.filter(POSTERIZE, 9);
      } else {
        graph.filter(POSTERIZE, 9);
      }

      //graph.filter(THRESHOLD, 0.55)
      if (monochrome > 0.9) {
        graph.filter(GRAY);
      }
    }

    if (clear > 0.5 && inverse < 0.4) {
      // graph.image(overAllTexture2, 0, 0);
    }

    if (slices < 9) {
      image(graph, 0, 0);
    } else if (inverse < 0.4) {
      image(graph, 0, -HEIGHT / 2 + 1 * M);
      image(graph, 0, HEIGHT / 2);
    } else if (inverse < 0.8 && slices % 4 == 0) {
      image(graph, -width / 2 + 1 * M, 0);
      image(graph, width / 2, 0);
    } else {
      image(graph, -width / 2 + 1 * M, -HEIGHT / 2 + 1 * M);
      image(graph, width / 2, -HEIGHT / 2 + 1 * M);
      image(graph, -width / 2 + 1 * M, HEIGHT / 2);
      image(graph, width / 2, HEIGHT / 2);
    }

    if (inverse >= 0.4) {
      if (clear > 0.4) {
        image(overAllTexture, 0, 0);
      }
      // if(clear > 0.7 && monochrome <=0.9){
      //     image(overAllTexture, 0, 0);
      // }
    }

    if (glitch > 0) {
      // granulateFuzzify(200)
    }
    //

    stroke(0, 0, 100);
    noFill();
    strokeWeight(100 * M);
    rect(0, 0, width, HEIGHT);
    fill(0, 0, 100);
    rect(0, high - 50 * M, width, 300 * M);

    fill(bgcol);
    if (bgcol[2] == 95) {
      fill(0, 0, 20);
    }

    const event = new Date(Date.now());
    const options = { year: "numeric", month: "long", day: "numeric" };
    let thisDate = event.toLocaleDateString("en-EN", options);

    noStroke();
    textSize(75 * M);
    textAlign(LEFT, BOTTOM);
    textFont("Helvetica");
    textStyle(BOLD);
    text("M O M E N T A", 48 * M, HEIGHT + 75 * M);
    textSize(20 * M);
    textAlign(RIGHT, BOTTOM);
    textStyle(ITALIC);
    text("MINT NUMBER", width - 50 * M, HEIGHT + 35 * M);
    textStyle(BOLDITALIC);
    text(mintnumber, width - 50 * M, HEIGHT + 60 * M);
  }

  class Drop {
    constructor(loc, dir, speed, color) {
      this.loc = loc;
      this.speed = speed;
      this.dir = dir;
      this.color = color;
    }

    draw() {
      graph.fill(this.color);
      graph.noStroke();
    }

    move() {
      let cc = color(this.color);
      cc.setAlpha(100);

      let anglenoise = noise(
        this.loc.x / noiseScale,
        this.loc.y / noiseScale,
        frameCount / noiseScale
      ); //; //0-2PI
      let angle = anglenoise * 360 * noiseStrength + direction;
      this.dir.x = cos(angle);
      this.dir.y = sin(angle);
      var vel = this.dir.copy();
      var d = 1; //direction change
      vel.mult(this.speed * d); //vel = vel * (speed*d)
      this.loc.add(vel); //loc = loc + vel

      if (this.loc.y > height - padding2) {
        this.loc.y = padding;
      } else if (this.loc.y < padding2) {
        this.loc.y = height - padding;
      }
      if (this.loc.x > width - padding2) {
        this.loc.x = padding;
      } else if (this.loc.x < padding2) {
        this.loc.x = width - padding;
      }

      if (slices < 9) {
        solid = 0.2;
        cc.setAlpha(random(2, 40));
      }
      // if(solid < 0.25){
      //     if(elliptical > 0.8){
      //         cc.setAlpha(random(2,25))
      //     }else{
      //         cc.setAlpha(random(2,50))
      //     }

      // }else
      else if (solid < 0.5) {
        if (elliptical > 0.8) {
          cc.setAlpha(random(4, 35));
        } else {
          cc.setAlpha(random(5, 35));
        }
      } else if (solid < 0.7) {
        cc.setAlpha(random(5, 35));
      } else {
        cc.setAlpha(random(5, 35));
      }
      //
      let mapping;
      // if(monochrome > 0.9){
      //     cc = color(cc[0], cc[1], 100)
      // }

      if (style > 1 && solid >= 0.4 && elliptical <= 0.8) {
        graph.stroke(color(bgcol[0], bgcol[1], bgcol[2], 40));

        graph.strokeWeight(60 * M);
        cc.setAlpha(random(25, 90));
      }
      graph.fill(cc);
      let w1 = colWidth * random(12, 30);
      let w2 = colWidth * random(8, 20);
      let w3 = colWidth * random(5, 15);
      let h1 = colWidth * random(12, 20);
      let h2 = colWidth * random(8, 30);
      let h3 = colWidth * random(5, 15);

      if (regular > 0) {
        if (elliptical > 0 && slices > 8) {
          graph.ellipse(this.loc.x, this.loc.y, w1, h1);
        } else {
          graph.rect(this.loc.x, this.loc.y, w1, h1);
        }
        if (solid < 0.5) {
          if (elliptical > 0 && slices > 8) {
            graph.ellipse(this.loc.x, this.loc.y, w2, h2);
            graph.ellipse(this.loc.x, this.loc.y, w3, h3);
            graph.ellipse(this.loc.x, this.loc.y, w2, h2);
            graph.ellipse(this.loc.x, this.loc.y, w3, h3);
          } else {
            graph.rect(this.loc.x, this.loc.y, w2, h2);
            graph.rect(this.loc.x, this.loc.y, w3, h3);
          }
        }
      } else {
        graph.ellipse(
          this.loc.x,
          this.locy,
          colWidth * rnd.random_num(1, 6),
          colWidth * rnd.random_num(1, 6)
        );
      }
    }
  }

  function bubbles(res, noiseSc, thresh) {
    res = res * M;

    let xx = width / res;
    let yy = height / res;

    for (let x = 0; x < xx; x++) {
      for (let y = 0; y < yy; y++) {
        let n = noise(x * noiseSc, y * noiseSc, frameCount * 0.008);

        // if(n > thresh){
        push();
        if (slices < 9) {
          graph.fill(0, 0, 100, 50 * n);
        } else {
          graph.fill(0, 0, 0, 50 * n);
        }

        graph.noStroke();
        // stroke(0,0,100,50)
        // strokeWeight(0.1)
        graph.ellipse(x * res, y * res, res * 2 * n * n, res * 2 * n * n);
        pop();
        // }
        // if(n > thresh){
        //     push()
        //     strokeWeight(n)
        //     stroke(0,0,100)
        //     line(x*res,0,x*res,height)
        //     pop()
        // }
      }
    }
  }

  function makeFilter() {
    colorMode(HSB, 360, 100, 100, 100);
    drawingContext.shadowColor = color(0, 0, 5, 10);
    overAllTexture = createGraphics(WIDTH, HEIGHT);
    overAllTexture.loadPixels();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        let mapper;
        let dayhue = bgcol[0];
        let daysat = bgcol[1];

        if (minutesNow <= 300 || minutesNow > 1260) {
          daylight = 0;
        } else if (minutesNow > 300 && minutesNow <= 1080) {
          daylight = map(minutesNow, 300, 480, 0, 20);
          if (minutesNow < 390) {
            dayhue = map(minutesNow, 300, 390, bgcol[0], 40);
          } else {
            dayhue = map(minutesNow, 390, 480, 40, bgcol[0]);
          }
        } else if (minutesNow > 1080) {
          daylight = map(minutesNow, 1080, 1260, 20, 0);
          if (minutesNow < 1170) {
            dayhue = map(minutesNow, 1080, 1170, bgcol[0], 30);
            daysat = map(minutesNow, 1080, 1170, bgcol[1], 90);
          } else {
            dayhue = map(minutesNow, 1170, 1260, 30, bgcol[0]);
            daysat = map(minutesNow, 1170, 1260, 90, bgcol[1]);
          }
        } else {
          daylight = 20;
        }

        if (daylight > 20) {
          daylight = 20;
        }
        if (daylight < 0) {
          daylight = 0;
        }

        if (noon == 1) {
          daylight = 20;
          console.log("noon ", daylight);
        }
        if (midnight == 1) {
          daylight = 0;
        }
        if (sunrise == 1) {
          dayhue = 30;
          daysat = 90;
          daylight = 20;
        }

        mapper = map(i, width / 4, width, daylight, bgcol[2] * 0.8);
        overAllTexture.set(
          i,
          j,
          color(
            dayhue,
            daysat,
            mapper,
            noise(i / 5, j / 5, (i * j) / 100) * rnd.random_num(5, 60)
          ) //noise(i*0.001,j*0.002))
        );
      }
    }
    overAllTexture.updatePixels();
  }

  function makeFilter2() {
    colorMode(HSB, 360, 100, 100, 100);
    drawingContext.shadowColor = color(0, 0, 5, 10);
    overAllTexture2 = createGraphics(WIDTH, HEIGHT);
    overAllTexture2.loadPixels();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        let mapper;
        let dayhue = bgcol[0];
        let daysat = bgcol[1];
        if (minutesNow <= 300 || minutesNow > 1260) {
          daylight = 0;
        } else if (minutesNow > 300 && minutesNow <= 1080) {
          daylight = map(minutesNow, 300, 480, 0, 20);
          if (minutesNow < 390) {
            dayhue = map(minutesNow, 300, 390, bgcol[0], 40);
          } else {
            dayhue = map(minutesNow, 390, 480, 40, bgcol[0]);
          }
        } else if (minutesNow > 1080) {
          daylight = map(minutesNow, 1080, 1260, 20, 0);
          if (minutesNow < 1170) {
            dayhue = map(minutesNow, 1080, 1170, bgcol[0], 30);
            daysat = map(minutesNow, 1080, 1170, bgcol[1], 90);
          } else {
            dayhue = map(minutesNow, 1170, 1260, 30, bgcol[0]);
            daysat = map(minutesNow, 1170, 1260, 90, bgcol[1]);
          }
        } else {
          daylight = 20;
        }

        if (daylight > 20) {
          daylight = 20;
        }
        if (daylight < 0) {
          daylight = 0;
        }

        if (noon == 1) {
          daylight = 20;
          console.log("noon: ", noon);
        }
        if (midnight == 1) {
          daylight = 0;
          console.log("midnight: ", midnight);
        }
        if (sunrise == 1) {
          dayhue = 30;
          daysat = 90;
          daylight = 20;
        }

        mapper = map(i, width / 4, width, daylight, bgcol[2] * 0.8);
        overAllTexture2.set(
          i,
          j,
          color(
            dayhue,
            daysat,
            mapper,
            noise(i / 5, j / 5, (i * j) / 100) * rnd.random_num(10, 89)
          ) //noise(i*0.001,j*0.002))
        );
      }
    }
    overAllTexture2.updatePixels();
  }

  function keyTyped() {
    if (key === "l" || key === "L") {
      saveCanvas(Seed, "png");
    }
    if (key === "f" || key === "F") {
      noLoop();
    }
    if (key === "p" || key === "P") {
      pixelDensity(1);
      loop();
    }
    if (key === "n" || key === "N") {
      midnight = 1;
      noon = 0;
      sunrise = 0;
      filters();
      loop();
    }
    if (key === "d" || key === "D") {
      noLoop();
      noon = 1;
      midnight = 0;
      sunrise = 0;
      filters();
      loop();
    }
    if (key === "s" || key === "S") {
      noLoop();
      sunrise = 1; // saveCanvas(Seed, "png");
      midnight = 0;
      noon = 0;
      filters();
      loop();
      console.log("sunrise");
    }
    if (key === "r" || key === "R") {
      midnight = 0;
      noon = 0; // saveCanvas(Seed, "png");
      sunrise = 0;
      pixelDensity(1);
      filters();
      loop();
    }
    //   if (key === "c" || key === "C") {
    //     poster = 0
    //     filters()
    //     loop()
    //   }
    if (key === "h" || key === "R") {
      hiDef();
    }
  }

  function mirror() {
    img = graph.get(0, 0, shape.a, shape.o);
    img.mask(mask);
    graph.push();
    graph.translate(width / 2, HEIGHT / 2);

    for (var i = 0; i < slices; i++) {
      if (i % 2 == 0) {
        graph.push();
        graph.scale(1, -1); // mirror
        graph.image(img, 0, 0); // draw slice
        graph.pop();
      } else {
        graph.rotate((360 / slices) * 2); // rotate
        graph.image(img, 0, 0); // draw slice
      }
    }
    graph.pop();
  }

  function calcStuff(width, height, s) {
    let a = sqrt(sq(width / 2) + sq(height / 2));
    let theta = 360 / s;
    let o = tan(theta) * a;
    let h = a / cos(theta);

    return { a: round(a), o: round(o), h: round(h) };
  }

  function createMask(w, h) {
    mask = graph.createImage(w, h);
    mask.loadPixels();
    for (i = 0; i < mask.width; i++) {
      for (j = 0; j < mask.height; j++) {
        if (i >= map(j, 0, h, 0, w) - 1) mask.set(i, j, color(255));
      }
    }
    mask.updatePixels();
    return mask;
  }

  function granulateFuzzify(_amount) {
    loadPixels();
    const d = pixelDensity();
    const fuzzyPixels = Math.floor(14);
    const modC = 4 * fuzzyPixels;
    const modW = 4 * width * d;
    const pixelsCount = modW * (height * d);
    for (let i = 0; i < pixelsCount; i += 4) {
      const f = modC + modW;
      if (pixels[i + f]) {
        pixels[i] = round((pixels[i] + pixels[i + f]) / 2);
        pixels[i + 2] = round((pixels[i + 2] + pixels[i + f + 2]) / 2);
        pixels[i + 3] = round((pixels[i + 3] + pixels[i + f + 3]) / 2);
      }
    }
    updatePixels();
  }

  function hiDef() {
    noLoop();
    pixelDensity(6);
    draw();
    saveCanvas(Seed + "_HD", "png");
    noLoop();
  }
</script>
