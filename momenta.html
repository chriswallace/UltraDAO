---
layout: default
title: Momenta
description: Collection #2 in the ULTRAPASS Curated series, by r0zk0.
permalink: /curated/2
id: curated-2
image: assets/images/momenta-preview.jpg
---

<div class="pt-8 sm:pt-20 pb-12 md:grid md:grid-cols-3 gap-8">
  <div class="md:col-span-2">
    <span
      class="inline-block mb-8 ddfont-400 text-sm md:text-md font-normal uppercase tracking-widest text-transparent bg-clip-text bg-gradient-to-r from-gold-300 to-gold-500"
      >Curated Series Two</span
    >

    <h1 class="mb-1">Momenta</h1>

    <div class="byline text-xl mb-8">
      <em class="text-stone-500">by</em>
      <span
        class="text-transparent bg-clip-text bg-gradient-to-r from-gold-300 to-gold-500"
        >r0zk0</span
      >
    </div>
    <p
      class="items-center font-light text-xl md:text-2xl text-neutral-400 mb-10 pb-0"
    >
      An artwork exploring the fleeting and ephemeral nature of daily experience
      through ever-changing outputs that never repeat themselves.
    </p>

    <div id="momentaPreview" class="preview-frame basis-1/2"></div>

    <div class="{{ page.markdown }} max-w-none leading-6 py-8">
      <div class="w-full max-w-none py-8 max-w-prose prose">
        <h2>About the collection</h2>

        <p>
          What sets "Momenta" apart from other generative art collections is its
          ever changing nature. Every time a token is loaded, a new and original
          starting point is created, taking the viewer on a unique journey only
          the will ever experience. Momenta will never look the same twice. The
          collection creates animations that evolve and transform in real-time,
          allowing viewers to witness the constant evolution of each piece.
        </p>

        <p>
          The momentary quality of these works is intentional; I wanted to
          create a collection that captured the essence of daily experience,
          something that is always present but never fully seen. I believe this
          encapsulates the beauty of living in the present moment, where time
          stands still and each moment is a delicate dance of light and color.
        </p>

        <p>
          The beauty of "Momenta" lies in its changing nature, which needs to be
          experienced over a certain period of time to fully appreciate. By
          taking the time to observe and appreciate the subtle shifts and
          transformations, viewers can immerse themselves in the ever-changing
          world of "Momenta."
        </p>

        <p>
          Through "Momenta," I hope to transport viewers to a world where time
          stands still and each moment is a delicate dance of light and color. I
          want to evoke a sense of wonder and awe at the beauty of our fleeting
          experiences, and to remind us all of the importance of living in the
          present moment.
        </p>
      </div>
    </div>
  </div>

  <div>
    <div class="p-10 border border-2 border-neutral-700 rounded-md">
      <h2>Mint details</h2>

      <p class="mb-2 font-light">Editions: 400</p>
      <p class="mb-2 font-light">Sale type: Dutch auction</p>
      <p class="mb-2 font-light">Date/time: July 20 @ 11AM EST</p>
      <p class="mb-2 font-light">
        Reserves: Available for
        <a href="https://ultradao.org/ultrapass">ULTRAPASS</a> and existing
        r0zk0 holders.
      </p>
      <p
        class="text-center mt-12 font-light text-sm uppercase text-stone-400 tracking-widest"
      >
        on-chain partner
        <a href="https://alba.art"
          ><svg
            version="1.1"
            id="alba"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            x="0px"
            y="0px"
            viewBox="0 0 60 16"
            style="enable-background: new 0 0 60 16"
            xml:space="preserve"
            class="alba-logo"
          >
            <path
              class="st0"
              d="M29,10.8V16H16.8v-0.4c1.1-0.1,1.7-0.7,1.7-1.8V2.2c0-1.1-0.6-1.7-1.7-1.8V0H23v0.4c-1.1,0.1-1.7,0.7-1.7,1.8
	v11.7c0,0.5,0.1,0.9,0.4,1.2c0.3,0.3,0.8,0.4,1.5,0.4h1.2c0.5,0,1-0.1,1.3-0.3c0.4-0.2,0.8-0.6,1.2-1.3c0.5-0.7,1-1.7,1.7-3.1H29z"
            />
            <path
              class="st0"
              d="M32.7,13.8V2.2c0-1.1-0.6-1.7-1.7-1.8V0h7.9c1.4,0,2.5,0.3,3.3,1c0.7,0.7,1.1,1.5,1.1,2.6
	c0,0.9-0.3,1.8-0.9,2.5C41.8,6.7,41,7.2,40,7.4C41.3,7.5,42.3,8,43,8.8c0.7,0.8,1.1,1.7,1.1,2.9c0,1.3-0.4,2.4-1.2,3.2
	C42.2,15.6,41,16,39.4,16H31v-0.4C32.1,15.5,32.7,14.9,32.7,13.8z M35.9,15.1c0.3,0.3,0.8,0.4,1.4,0.4h1.2c0.9,0,1.6-0.3,2-0.9
	c0.5-0.6,0.7-1.6,0.7-3c0-2.6-0.9-3.9-2.8-3.9h-3v6.1C35.4,14.4,35.6,14.8,35.9,15.1z M38.2,7.2c1.5,0,2.3-1.1,2.3-3.3
	c0-1.2-0.2-2.1-0.7-2.6c-0.4-0.5-1.1-0.8-1.9-0.8h-1.4c-0.5,0-0.7,0.1-0.9,0.2c-0.2,0.2-0.2,0.4-0.2,0.8v5.6H38.2z"
            />
            <path
              class="st0"
              d="M1.4,14.4c0.5-0.6,0.9-1.6,1.4-2.9L6.4,0h2.1l4.3,13c0.3,0.9,0.6,1.6,1,2c0.3,0.4,0.7,0.6,1.2,0.7V16H8.9v-0.4
	c0.6,0,1-0.2,1.3-0.3c0.2-0.2,0.4-0.4,0.4-0.8c0-0.2-0.1-0.6-0.2-1.1L9.1,9.7L6.4,1.8L3.9,9.7L3.2,12c-0.2,0.5-0.3,1-0.3,1.4
	c0,0.5,0.1,0.9,0.5,1.2c0.3,0.4,0.8,0.7,1.6,1V16H0v-0.4C0.4,15.5,0.9,15.1,1.4,14.4z"
            />
            <path
              class="st0"
              d="M46.2,14.4c0.5-0.6,0.9-1.6,1.4-2.9L51.3,0h2.1l4.3,13c0.3,0.9,0.6,1.6,1,2c0.3,0.4,0.7,0.6,1.2,0.7V16h-6.2
	v-0.4c0.6,0,1-0.2,1.3-0.3c0.2-0.2,0.4-0.4,0.4-0.8c0-0.2-0.1-0.6-0.2-1.1l-1.3-3.8l-2.6-7.9l-2.5,7.9L48,12c-0.2,0.5-0.3,1-0.3,1.4
	c0,0.5,0.1,0.9,0.5,1.2c0.3,0.4,0.8,0.7,1.6,1V16h-4.9v-0.4C45.3,15.5,45.7,15.1,46.2,14.4z"
            />
          </svg>
        </a>
      </p>
    </div>
  </div>
</div>

<div
  class="grid md:grid-cols-3 gap-4 md:gap-12 max-w-full content-around justify-items-center items-center place-content-center -mx-2 overflow-hidden sm:-mx-2"
>
  <div>
    <img src="/assets/images/momenta-preview.jpg" alt="Momenta Preview #1" />
  </div>

  <div>
    <img src="/assets/images/momenta-preview2.jpg" alt="Momenta Preview #2" />
  </div>

  <div>
    <img src="/assets/images/momenta-preview3.jpg" alt="Momenta Preview #3" />
  </div>
</div>

<div class="{{ page.markdown }} max-w-none leading-6 py-8">
  <div class="w-full max-w-none py-8 max-w-prose prose">
    <span class="inline-block mb-2 caps font-light text-lg"
      >About the artist</span
    >

    <h2 class="mt-0 pt-0">r0zk0</h2>

    <img
      src="/assets/images/r0zk0-photo.jpg"
      class="float-left mr-6 mb-4 rounded-md max-w-[25%]"
      width="180"
      alt="r0zk0"
    />

    <p>
      Chris (aka r0zk0) is a generative artist based in Hamburg, Germany with an
      affinity for exploring dynamism in generative art. In 2022, he released
      two highly-celebrated long-form collections via GEN.ART and Art Blocks.
    </p>

    <p>
      r0zk0's work is focused on minimalism, both conceptually and visually. He
      explores organic textures and structures and is fascinated by the
      generative power of simple algorithms.
    </p>

    <p>
      Avalon, released on Art Blocks in 2022, was particularly unique in
      showcasing r0zk0's talent. Each artwork is a map positioned on a virtual
      globe that experience 12.5 hour tidal cycles based on a virtual moon
      orbit. It then updates every two minutes to reflect the changing tides.
    </p>
  </div>
</div>

<style type="text/css">
  .btn-go > span {
    border-radius: 5px;
    padding: 2px;
  }

  .btn-go > span > span {
    background-color: #000;
    border-radius: 3px;
  }
</style>

<script
  language="javascript"
  type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/p5@1.3.1/lib/p5.js"
></script>

<script>
  p5.disableFriendlyErrors = true;

  function genTokenData(projectNum) {
    let data = {};
    let hash = "0x";
    for (var i = 0; i < 64; i++) {
      hash += Math.floor(Math.random() * 16).toString(16);
    }
    data.hash = hash;
    data.tokenId = (
      projectNum * 1000000 +
      Math.floor(Math.random() * 208)
    ).toString();
    return data;
  }
  let tokenData = genTokenData(123);

  // tokenData.hash = '0xfd0cd766df001660989c3e04a2900bbfe6bbff26f431520b6e849303dfd3ceaa'

  class Random {
    constructor() {
      this.useA = false;
      let sfc32 = function (uint128Hex) {
        let a = parseInt(uint128Hex.substr(0, 8), 16);
        let b = parseInt(uint128Hex.substr(8, 8), 16);
        let c = parseInt(uint128Hex.substr(16, 8), 16);
        let d = parseInt(uint128Hex.substr(24, 8), 16);
        return function () {
          a |= 0;
          b |= 0;
          c |= 0;
          d |= 0;
          let t = (((a + b) | 0) + d) | 0;
          d = (d + 1) | 0;
          a = b ^ (b >>> 9);
          b = (c + (c << 3)) | 0;
          c = (c << 21) | (c >>> 11);
          c = (c + t) | 0;
          return (t >>> 0) / 4294967296;
        };
      };
      // seed prngA with first half of tokenData.hash
      this.prngA = new sfc32(tokenData.hash.substr(2, 32));
      // seed prngB with second half of tokenData.hash
      this.prngB = new sfc32(tokenData.hash.substr(34, 32));
      for (let i = 0; i < 1e6; i += 2) {
        this.prngA();
        this.prngB();
      }
    }
    // random number between 0 (inclusive) and 1 (exclusive)
    random_dec() {
      this.useA = !this.useA;
      return this.useA ? this.prngA() : this.prngB();
    }
    // random number between a (inclusive) and b (exclusive)
    random_num(a, b) {
      return a + (b - a) * this.random_dec();
    }
    // random integer between a (inclusive) and b (inclusive)
    // requires a < b for proper probability distribution
    random_int(a, b) {
      return Math.floor(this.random_num(a, b + 1));
    }
    // random boolean with p as percent liklihood of true
    random_bool(p) {
      return this.random_dec() < p;
    }
    // random value in an array of items
    random_choice(list) {
      return list[this.random_int(0, list.length - 1)];
    }
  }

  const Seed = tokenData.hash;
  let rnd = new Random();
  const screenMode =
    document.getElementById("momentaPreview").clientWidth <=
    document.getElementById("momentaPreview").clientHeight * 1
      ? 1
      : 0;
  // const random = new Random(Seed)
  const DEFAULT_SIZE = 1200;
  // const HEIGHT = Math.floor(!screenMode ? document.getElementById('momentaPreview').clientHeight : document.getElementById('momentaPreview').clientWidth *1.41)
  const high = Math.floor(
    document.getElementById("momentaPreview").clientHeight * 0.6
  );
  const WIDTH = Math.floor(high / 1.5);
  const HEIGHT = Math.floor(WIDTH * 1.41);
  const DIM = Math.min(WIDTH, high);
  const M = DIM / DEFAULT_SIZE;

  function gauss() {
    var u = 0,
      v = 0;
    while (u === 0) u = rnd.random_dec(); //Converting [0,1) to (0,1)
    while (v === 0) v = rnd.random_dec();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
  }

  // let slices = rnd.random_int(4,12)*2;
  let slices = rnd.random_int(2, 6) * 4;
  let numShapes;

  var shape, mask, img;

  const fuzzyPixels = 12; // pixels

  let threshold = 0.4;

  let starting = 1;

  let style;
  let solid = rnd.random_dec();
  let clear = rnd.random_dec();
  let monochrome = rnd.random_dec();
  let inverse = rnd.random_dec();
  let elliptical = rnd.random_dec();
  let density = rnd.random_dec();
  let glitch = rnd.random_dec();
  let colorful = rnd.random_dec();
  let midnight = 0;
  let noon = 0;
  let sunrise = 0;
  let daylight;
  let graph;
  // let high
  let rndPix;

  let poster = 1;

  var padding = -200 * M;
  var padding2 = -500 * M;
  let start = 0;
  var startHeight;
  let cols;
  let colWidth;
  let runs = 0;
  let drops = [];
  let regular;
  let angular;
  let bold;
  let direction;

  let minutesNow;

  let mintnumber;

  var t;
  var num, vNum;
  var radius, mySize;
  var sizes = [];

  let v_planet = [];

  let maxruns;

  let colors = [];
  let color_setup = [];
  let backgrounds = [];
  let bgcol = [];

  color_setup[0] = "FCDE9C-FFA552-BA5624-381D2A-C4D6B0"
    .split("-")
    .map((a) => "#" + a);
  color_setup[1] = "f8f9fbBF-f9f6e040-45454cBF-ef9643b3-f0654380"
    .split("-")
    .map((a) => "#" + a);
  color_setup[2] = "f8f9fb-f9f6e0-45454c-ef9643-f06543"
    .split("-")
    .map((a) => "#" + a);
  //color_setup[3] = "fefefe-fffffb-fafdff-fef9fb-f7fcfe".split("-").map((a) => "#" + a);
  color_setup[3] = "084C61-DB504A-E3B505-4F6D7A-56A3A6"
    .split("-")
    .map((a) => "#" + a);

  color_setup[4] =
    "8c75ff-c553d2-2788f5-23054f-f21252-8834f1-c4dd92-184fd3-f9fee2-2E294E-541388-F1E9DA-FFD400-D90368-e9baaa-ffa07a-164555-ffe1d0-acd9e7-4596c7-6d8370-e45240-21d3a4-3303f9-cd2220-173df6-244ca8-a00360-b31016"
      .split("-")
      .map((a) => "#" + a);
  color_setup[5] = "025159-3E848C-7AB8BF-C4EEF2-A67458"
    .split("-")
    .map((a) => "#" + a);
  color_setup[6] = "10454F-506266-818274-A3AB78-BDE038"
    .split("-")
    .map((a) => "#" + a);
  color_setup[7] = "D96690-F28DB2-F2C9E0-89C2D9-88E8F2"
    .split("-")
    .map((a) => "#" + a);
  //color_setup[8] = "3D3522-4A442D-202020-58B09C-CAF7E2".split("-").map((a) => "#" + a);
  color_setup[8] = "FCDE9C-FFA552-BA5624-381D2A-C4D6B0"
    .split("-")
    .map((a) => "#" + a);
  color_setup[9] = "773344-E3B5A4-F5E9E2-0B0014-D44D5C"
    .split("-")
    .map((a) => "#" + a);
  color_setup[10] = "084C61-DB504A-E3B505-4F6D7A-56A3A6"
    .split("-")
    .map((a) => "#" + a);
  color_setup[11] = "EEE2DF-EED7C5-C89F9C-C97C5D-B36A5E"
    .split("-")
    .map((a) => "#" + a);
  // color_setup[12]= "000000-14213D-FCA311-E5E5E5-FFFFFF".split("-").map((a) => "#" + a);
  color_setup[12] = "0D1B2A-1B263B-415A77-778DA9-E0E1DD"
    .split("-")
    .map((a) => "#" + a);
  color_setup[13] = "0D1B2A-1B263B-415A77-778DA9-E0E1DD"
    .split("-")
    .map((a) => "#" + a);

  var color_setup1, color_setup2;

  let color_bg;

  let newSeed = Date.now();
  // var rndSeed = 'Seed'+newSeed
  var rndSeed = newSeed;
  var a = 2,
    b = 3;
  var th = 0,
    seg = 0.006;
  var r;
  var mySize;

  var noiseScale = 220,
    noiseStrength = 0.3;

  function setup() {
    randomSeed(rndSeed);
    console.log(Seed);
    rndPix = 14 * M;
    mintnumber = rnd.random_int(0, 300);
    if (mintnumber < 10) {
      mintnumber = "00" + mintnumber;
    } else if (mintnumber < 100) {
      mintnumber = "0" + mintnumber;
    }

    angleMode(DEGREES);
    direction = rnd.random_num(0, 360);

    regular = rnd.random_dec();
    angular = rnd.random_dec();
    bold = rnd.random_dec();

    if (inverse >= 0.4) {
      slices = rnd.random_int(2, 6) * 4;
    }

    style = rnd.random_dec();

    //   blendMode(HARD_LIGHT)

    mySize = min(windowWidth, windowHeight) * 0; //random(0.8,1.1);

    var myCanvas = createCanvas(WIDTH, HEIGHT); //high);
    myCanvas.parent("momentaPreview");
    pixelDensity(1);
    frameRate(25);

    graph = createGraphics(WIDTH, HEIGHT);
    graph.angleMode(DEGREES);
    graph.pixelDensity(1);
    colorMode(HSB, 360, 100, 100, 100);
    r = mySize / 2;

    if (density < 0 && monochrome > 0.9 && elliptical > 0.8) {
      cols = rnd.random_int(500, 900); //DEFAULT 180
    } else if (density < 0.6 && elliptical <= 0.8) {
      cols = rnd.random_int(20, 45); //DEFAULT 180 // CHECK used to be 35,80
    } else {
      cols = rnd.random_int(40, 65); // cols = rnd.random_int(70,160) //DEFAULT 180
    }
    if (slices < 9) {
      cols = rnd.random_int(40, 80);
    }

    console.log("cols: ", cols);

    colWidth = (width - 2 * padding) / cols;
    let bgPicker;
    if (slices < 9) {
      bgPicker = rnd.random_int(0, 4);
    } else {
      bgPicker = rnd.random_int(4, 7);
    }

    backgrounds[0] = [10, 80, 40];
    backgrounds[1] = [0, 0, 35];
    backgrounds[2] = [60, 2, 30];
    backgrounds[3] = [234, 86, 27];
    backgrounds[4] = [0, 0, 95];
    backgrounds[5] = [200, 14, 90];
    backgrounds[6] = [41, 15, 97];
    backgrounds[7] = [0, 0, 95];

    bgcol = backgrounds[bgPicker];

    if (slices < 9) {
      numShapes = 600; //cols*rnd.random_num(0.15,0.35);//rnd.random_int(250,400)//cols*rnd.random_num(0.5,2);
    } else {
      numShapes = rnd.random_int(50, 150); //cols*rnd.random_num(0.15,0.35);//rnd.random_int(250,400)//cols*rnd.random_num(0.5,2);
    }

    console.log("shapes: ", numShapes);

    graph.background(color(bgcol[0], bgcol[1], bgcol[2]));

    console.log(bgcol[2]);

    //   color_setup1 = colors7;
    let colPicker = rnd.random_int(0, 13);

    color_setup2 = color_setup[colPicker];

    colors[0] = rnd.random_choice(color_setup2); //rnd.random_choice(colors7);

    colors[1] = rnd.random_choice(color_setup2);
    if (colorful > 0.5 || slices < 9) {
      colors[2] = rnd.random_choice(color_setup2);
      colors[3] = rnd.random_choice(color_setup2);
    }
    if (slices < 9) {
      colors[4] = rnd.random_choice(color_setup2);
    }

    console.log("colors: ", colors);
    // background(color_bg);
    if (bold > 0.5) {
      num = rnd.random_int(3, 6);
    } else {
      num = rnd.random_int(4, 8);
    }

    let speedX = 0; //random(-1.5,1.5)
    for (let i = 0; i < cols; i++) {
      let strokeCol = color(rnd.random_choice(colors));
      let loc = createVector(
        padding + i * colWidth + colWidth / 4,
        random(padding, height - padding)
      );
      let angle = 180; //any value to initialize
      let dir = createVector(cos(angle), sin(angle));
      let speed = rnd.random_num(0.07, 0.33); // default: 0.9

      if (regular > 0) {
        drops[i] = new Drop(loc, dir, speed, strokeCol);
      }
      drops[i].draw();
    }

    radius = mySize * 1;
    for (let a = 0; a < TAU; a += TAU / num) {
      // sizes.push(random(0.1, 0.5))
      sizes.push(rnd.random_num(0.01, 0.5));
    }
    t = 0;

    shape = calcStuff(WIDTH, HEIGHT, slices);
    mask = createMask(shape.a, shape.o);

    background(0, 0, 0);
    filters();

    ///FEATURES

    //PALETTE: ...
    let palettes = [];
    palettes[0] = "74-75";
    palettes[1] = "Fire and Rain";
    palettes[2] = "Orange Crush";
    palettes[3] = "Ashes to Ashes";
    palettes[4] = "Shes a Rainbow";
    palettes[5] = "Cold Cold Ground";
    palettes[6] = "High & Dry";
    palettes[7] = "Pop Crimes";
    palettes[8] = "Camouflage";
    palettes[9] = "Fear and Love";
    palettes[10] = "Common People";
    palettes[11] = "Natural Anthem";
    palettes[12] = "A Simple Love";
    palettes[13] = "Sour Soul";
    let palette_f = palettes[colPicker];

    //BACKGROUND: ...

    let backgroundCol = [];

    backgroundCol[0] = "Ore";
    backgroundCol[1] = "Obsidian";
    backgroundCol[2] = "Granite";
    backgroundCol[3] = "Sapphire";
    backgroundCol[4] = "Alabaster";
    let background_f = backgroundCol[bgPicker];

    // SLICES: Number
    console.log("SEGMENTS: ", slices / 2);
    let segments_f = slices / 2;

    //SHAPE: elliptical / angular
    let shape_f;
    if (elliptical > 0.8 && solid < 0.7 && slices > 8) {
      shape_f = "Elliptical";
    } else {
      shape_f = "Angular";
    }

    //SYMMETRY: center, corners, horizontal, vertical
    if (inverse < 0.4) {
      symmetry_f = "Center";
    } else if (inverse < 0.5) {
      symmetry_f = "Horizontal";
    } else if (inverse < 0.6) {
      symmetry_f = "Vertical";
    } else {
      symmetry_f = "Corners";
    }

    //HAZE: low, medium, high
    let haze_f = "Low";
    if (clear > 0.5 && inverse < 0.4) {
      haze_f = "Medium";
    }
    if (inverse >= 0.4) {
      if (clear > 0.4) {
        haze_f = "Medium";
      }
      if (clear > 0.7 && monochrome <= 0.9) {
        haze_f = "High";
      }
    }

    //MONOCHROME: yes, no

    if (monochrome > 0.9) {
      mono_f = "Yes";
    } else {
      mono_f = "No";
    }

    let features = {
      Palette: palette_f,
      Background: background_f,
      Segments: segments_f,
      Shape: shape_f,
      Symmetry: symmetry_f,
      Haze: haze_f,
      Monochrome: mono_f,
    };

    console.log(features);
  }

  function filters() {
    let filter = new makeFilter();
    let filter2 = new makeFilter2();
    draw();
  }

  function draw() {
    let today = new Date();
    minutesNow = today.getHours() * 60 + today.getMinutes();

    if (minutesNow % 30000 == 0) {
      filters();
    }

    randomSeed(rndSeed);

    let ccc = color(bgcol[0], bgcol[1], bgcol[2]);
    if (slices < 9) {
      ccc.setAlpha(20);
    } else {
      ccc.setAlpha(100);
    }

    background(0, 0, 100);
    graph.background(ccc);
    if (monochrome <= 0.9) {
      graph.background(ccc);
    }
    //   }

    noFill();
    graph.strokeCap(ROUND);

    push();
    stroke(0, 0, 100, 30);
    strokeWeight(0.5 * M);
    pop();

    graph.push();

    for (let i = 0; i < cols; i += 1) {
      noStroke();
      drops[i].move();
    }
    graph.pop();

    t += rnd.random_num(-0.0012, 0.0012);

    th += seg;

    graph.image(overAllTexture2, 0, 0);

    runs += 1;
    mirror();

    bubbles(15, 0.05, 0.7);

    if (slices < 9) {
      monochrome = 0;
    }

    //   if(monochrome > 0.9){

    //     }else if(monochrome >0.4){
    //         if(poster == 1){
    //         //graph.filter(POSTERIZE, 9   )
    //         }

    //     }
    //
    //
    if (poster == 1) {
      if (slices < 9) {
        graph.filter(POSTERIZE, 9);
      } else {
        graph.filter(POSTERIZE, 9);
      }

      //graph.filter(THRESHOLD, 0.55)
      if (monochrome > 0.9) {
        graph.filter(GRAY);
      }
    }

    if (clear > 0.5 && inverse < 0.4) {
      // graph.image(overAllTexture2, 0, 0);
    }

    if (slices < 9) {
      image(graph, 0, 0);
    } else if (inverse < 0.4) {
      image(graph, 0, -HEIGHT / 2 + 1 * M);
      image(graph, 0, HEIGHT / 2);
    } else if (inverse < 0.8 && slices % 4 == 0) {
      image(graph, -width / 2 + 1 * M, 0);
      image(graph, width / 2, 0);
    } else {
      image(graph, -width / 2 + 1 * M, -HEIGHT / 2 + 1 * M);
      image(graph, width / 2, -HEIGHT / 2 + 1 * M);
      image(graph, -width / 2 + 1 * M, HEIGHT / 2);
      image(graph, width / 2, HEIGHT / 2);
    }

    if (inverse >= 0.4) {
      if (clear > 0.4) {
        image(overAllTexture, 0, 0);
      }
      // if(clear > 0.7 && monochrome <=0.9){
      //     image(overAllTexture, 0, 0);
      // }
    }

    if (glitch > 0) {
      // granulateFuzzify(200)
    }
    //

    stroke(0, 0, 100);
    noFill();
    strokeWeight(100 * M);
    rect(0, 0, width, HEIGHT);
    fill(0, 0, 100);
    rect(0, high - 50 * M, width, 300 * M);

    fill(bgcol);
    if (bgcol[2] == 95) {
      fill(0, 0, 20);
    }

    const event = new Date(Date.now());
    const options = { year: "numeric", month: "long", day: "numeric" };
    let thisDate = event.toLocaleDateString("en-EN", options);

    noStroke();
    textSize(75 * M);
    textAlign(LEFT, BOTTOM);
    textFont("Helvetica");
    textStyle(BOLD);
    text("M O M E N T A", 48 * M, HEIGHT + 75 * M);
    textSize(20 * M);
    textAlign(RIGHT, BOTTOM);
    textStyle(ITALIC);
    text("MINT NUMBER", width - 50 * M, HEIGHT + 35 * M);
    textStyle(BOLDITALIC);
    text(mintnumber, width - 50 * M, HEIGHT + 60 * M);
  }

  class Drop {
    constructor(loc, dir, speed, color) {
      this.loc = loc;
      this.speed = speed;
      this.dir = dir;
      this.color = color;
    }

    draw() {
      graph.fill(this.color);
      graph.noStroke();
    }

    move() {
      let cc = color(this.color);
      cc.setAlpha(100);

      let anglenoise = noise(
        this.loc.x / noiseScale,
        this.loc.y / noiseScale,
        frameCount / noiseScale
      ); //; //0-2PI
      let angle = anglenoise * 360 * noiseStrength + direction;
      this.dir.x = cos(angle);
      this.dir.y = sin(angle);
      var vel = this.dir.copy();
      var d = 1; //direction change
      vel.mult(this.speed * d); //vel = vel * (speed*d)
      this.loc.add(vel); //loc = loc + vel

      if (this.loc.y > height - padding2) {
        this.loc.y = padding;
      } else if (this.loc.y < padding2) {
        this.loc.y = height - padding;
      }
      if (this.loc.x > width - padding2) {
        this.loc.x = padding;
      } else if (this.loc.x < padding2) {
        this.loc.x = width - padding;
      }

      if (slices < 9) {
        solid = 0.2;
        cc.setAlpha(random(2, 40));
      }
      // if(solid < 0.25){
      //     if(elliptical > 0.8){
      //         cc.setAlpha(random(2,25))
      //     }else{
      //         cc.setAlpha(random(2,50))
      //     }

      // }else
      else if (solid < 0.5) {
        if (elliptical > 0.8) {
          cc.setAlpha(random(4, 35));
        } else {
          cc.setAlpha(random(5, 35));
        }
      } else if (solid < 0.7) {
        cc.setAlpha(random(5, 35));
      } else {
        cc.setAlpha(random(5, 35));
      }
      //
      let mapping;
      // if(monochrome > 0.9){
      //     cc = color(cc[0], cc[1], 100)
      // }

      if (style > 1 && solid >= 0.4 && elliptical <= 0.8) {
        graph.stroke(color(bgcol[0], bgcol[1], bgcol[2], 40));

        graph.strokeWeight(60 * M);
        cc.setAlpha(random(25, 90));
      }
      graph.fill(cc);
      let w1 = colWidth * random(12, 30);
      let w2 = colWidth * random(8, 20);
      let w3 = colWidth * random(5, 15);
      let h1 = colWidth * random(12, 20);
      let h2 = colWidth * random(8, 30);
      let h3 = colWidth * random(5, 15);

      if (regular > 0) {
        if (elliptical > 0 && slices > 8) {
          graph.ellipse(this.loc.x, this.loc.y, w1, h1);
        } else {
          graph.rect(this.loc.x, this.loc.y, w1, h1);
        }
        if (solid < 0.5) {
          if (elliptical > 0 && slices > 8) {
            graph.ellipse(this.loc.x, this.loc.y, w2, h2);
            graph.ellipse(this.loc.x, this.loc.y, w3, h3);
            graph.ellipse(this.loc.x, this.loc.y, w2, h2);
            graph.ellipse(this.loc.x, this.loc.y, w3, h3);
          } else {
            graph.rect(this.loc.x, this.loc.y, w2, h2);
            graph.rect(this.loc.x, this.loc.y, w3, h3);
          }
        }
      } else {
        graph.ellipse(
          this.loc.x,
          this.locy,
          colWidth * rnd.random_num(1, 6),
          colWidth * rnd.random_num(1, 6)
        );
      }
    }
  }

  function bubbles(res, noiseSc, thresh) {
    res = res * M;

    let xx = width / res;
    let yy = height / res;

    for (let x = 0; x < xx; x++) {
      for (let y = 0; y < yy; y++) {
        let n = noise(x * noiseSc, y * noiseSc, frameCount * 0.008);

        // if(n > thresh){
        push();
        if (slices < 9) {
          graph.fill(0, 0, 100, 50 * n);
        } else {
          graph.fill(0, 0, 0, 50 * n);
        }

        graph.noStroke();
        // stroke(0,0,100,50)
        // strokeWeight(0.1)
        graph.ellipse(x * res, y * res, res * 2 * n * n, res * 2 * n * n);
        pop();
        // }
        // if(n > thresh){
        //     push()
        //     strokeWeight(n)
        //     stroke(0,0,100)
        //     line(x*res,0,x*res,height)
        //     pop()
        // }
      }
    }
  }

  function makeFilter() {
    colorMode(HSB, 360, 100, 100, 100);
    drawingContext.shadowColor = color(0, 0, 5, 10);
    overAllTexture = createGraphics(WIDTH, HEIGHT);
    overAllTexture.loadPixels();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        let mapper;
        let dayhue = bgcol[0];
        let daysat = bgcol[1];

        if (minutesNow <= 300 || minutesNow > 1260) {
          daylight = 0;
        } else if (minutesNow > 300 && minutesNow <= 1080) {
          daylight = map(minutesNow, 300, 480, 0, 20);
          if (minutesNow < 390) {
            dayhue = map(minutesNow, 300, 390, bgcol[0], 40);
          } else {
            dayhue = map(minutesNow, 390, 480, 40, bgcol[0]);
          }
        } else if (minutesNow > 1080) {
          daylight = map(minutesNow, 1080, 1260, 20, 0);
          if (minutesNow < 1170) {
            dayhue = map(minutesNow, 1080, 1170, bgcol[0], 30);
            daysat = map(minutesNow, 1080, 1170, bgcol[1], 90);
          } else {
            dayhue = map(minutesNow, 1170, 1260, 30, bgcol[0]);
            daysat = map(minutesNow, 1170, 1260, 90, bgcol[1]);
          }
        } else {
          daylight = 20;
        }

        if (daylight > 20) {
          daylight = 20;
        }
        if (daylight < 0) {
          daylight = 0;
        }

        if (noon == 1) {
          daylight = 20;
          console.log("noon ", daylight);
        }
        if (midnight == 1) {
          daylight = 0;
        }
        if (sunrise == 1) {
          dayhue = 30;
          daysat = 90;
          daylight = 20;
        }

        mapper = map(i, width / 4, width, daylight, bgcol[2] * 0.8);
        overAllTexture.set(
          i,
          j,
          color(
            dayhue,
            daysat,
            mapper,
            noise(i / 5, j / 5, (i * j) / 100) * rnd.random_num(5, 60)
          ) //noise(i*0.001,j*0.002))
        );
      }
    }
    overAllTexture.updatePixels();
  }

  function makeFilter2() {
    colorMode(HSB, 360, 100, 100, 100);
    drawingContext.shadowColor = color(0, 0, 5, 10);
    overAllTexture2 = createGraphics(WIDTH, HEIGHT);
    overAllTexture2.loadPixels();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        let mapper;
        let dayhue = bgcol[0];
        let daysat = bgcol[1];
        if (minutesNow <= 300 || minutesNow > 1260) {
          daylight = 0;
        } else if (minutesNow > 300 && minutesNow <= 1080) {
          daylight = map(minutesNow, 300, 480, 0, 20);
          if (minutesNow < 390) {
            dayhue = map(minutesNow, 300, 390, bgcol[0], 40);
          } else {
            dayhue = map(minutesNow, 390, 480, 40, bgcol[0]);
          }
        } else if (minutesNow > 1080) {
          daylight = map(minutesNow, 1080, 1260, 20, 0);
          if (minutesNow < 1170) {
            dayhue = map(minutesNow, 1080, 1170, bgcol[0], 30);
            daysat = map(minutesNow, 1080, 1170, bgcol[1], 90);
          } else {
            dayhue = map(minutesNow, 1170, 1260, 30, bgcol[0]);
            daysat = map(minutesNow, 1170, 1260, 90, bgcol[1]);
          }
        } else {
          daylight = 20;
        }

        if (daylight > 20) {
          daylight = 20;
        }
        if (daylight < 0) {
          daylight = 0;
        }

        if (noon == 1) {
          daylight = 20;
          console.log("noon: ", noon);
        }
        if (midnight == 1) {
          daylight = 0;
          console.log("midnight: ", midnight);
        }
        if (sunrise == 1) {
          dayhue = 30;
          daysat = 90;
          daylight = 20;
        }

        mapper = map(i, width / 4, width, daylight, bgcol[2] * 0.8);
        overAllTexture2.set(
          i,
          j,
          color(
            dayhue,
            daysat,
            mapper,
            noise(i / 5, j / 5, (i * j) / 100) * rnd.random_num(10, 89)
          ) //noise(i*0.001,j*0.002))
        );
      }
    }
    overAllTexture2.updatePixels();
  }

  function keyTyped() {
    if (key === "l" || key === "L") {
      saveCanvas(Seed, "png");
    }
    if (key === "f" || key === "F") {
      noLoop();
    }
    if (key === "p" || key === "P") {
      pixelDensity(1);
      loop();
    }
    if (key === "n" || key === "N") {
      midnight = 1;
      noon = 0;
      sunrise = 0;
      filters();
      loop();
    }
    if (key === "d" || key === "D") {
      noLoop();
      noon = 1;
      midnight = 0;
      sunrise = 0;
      filters();
      loop();
    }
    if (key === "s" || key === "S") {
      noLoop();
      sunrise = 1; // saveCanvas(Seed, "png");
      midnight = 0;
      noon = 0;
      filters();
      loop();
      console.log("sunrise");
    }
    if (key === "r" || key === "R") {
      midnight = 0;
      noon = 0; // saveCanvas(Seed, "png");
      sunrise = 0;
      pixelDensity(1);
      filters();
      loop();
    }
    //   if (key === "c" || key === "C") {
    //     poster = 0
    //     filters()
    //     loop()
    //   }
    if (key === "h" || key === "R") {
      hiDef();
    }
  }

  function mirror() {
    img = graph.get(0, 0, shape.a, shape.o);
    img.mask(mask);
    graph.push();
    graph.translate(width / 2, HEIGHT / 2);

    for (var i = 0; i < slices; i++) {
      if (i % 2 == 0) {
        graph.push();
        graph.scale(1, -1); // mirror
        graph.image(img, 0, 0); // draw slice
        graph.pop();
      } else {
        graph.rotate((360 / slices) * 2); // rotate
        graph.image(img, 0, 0); // draw slice
      }
    }
    graph.pop();
  }

  function calcStuff(width, height, s) {
    let a = sqrt(sq(width / 2) + sq(height / 2));
    let theta = 360 / s;
    let o = tan(theta) * a;
    let h = a / cos(theta);

    return { a: round(a), o: round(o), h: round(h) };
  }

  function createMask(w, h) {
    mask = graph.createImage(w, h);
    mask.loadPixels();
    for (i = 0; i < mask.width; i++) {
      for (j = 0; j < mask.height; j++) {
        if (i >= map(j, 0, h, 0, w) - 1) mask.set(i, j, color(255));
      }
    }
    mask.updatePixels();
    return mask;
  }

  function granulateFuzzify(_amount) {
    loadPixels();
    const d = pixelDensity();
    const fuzzyPixels = Math.floor(14);
    const modC = 4 * fuzzyPixels;
    const modW = 4 * width * d;
    const pixelsCount = modW * (height * d);
    for (let i = 0; i < pixelsCount; i += 4) {
      const f = modC + modW;
      if (pixels[i + f]) {
        pixels[i] = round((pixels[i] + pixels[i + f]) / 2);
        pixels[i + 2] = round((pixels[i + 2] + pixels[i + f + 2]) / 2);
        pixels[i + 3] = round((pixels[i + 3] + pixels[i + f + 3]) / 2);
      }
    }
    updatePixels();
  }

  function hiDef() {
    noLoop();
    pixelDensity(6);
    draw();
    saveCanvas(Seed + "_HD", "png");
    noLoop();
  }
</script>
